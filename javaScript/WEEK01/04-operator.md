# 연산자
## 들어가기 전..

- 연산자(operator)란?

  - 연산자는 하나 이상의 표현식을 대상으로 연산을 수행하여 하나의 값을 만듦.

  - 연산의 대상은 <b>피연산자(operand)</b>라고 하는데, 피연산자는 표현식이어야 함.

- 부수 효과(side effect)란?

  - 연산에 의해 피연산자의 값이 변경되는 것을 의미함.

___
## 산술 연산자(arithmetic operator)

- 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행하여 새로운 <b>숫자 값</b>을 만듦.

- 산술이 불가능한 경우에는 `NaN`을 반환함.

  ```js
  console.log(3 + undefined); // NaN
  ```

- 피연산자 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분함.

### 이항(binary) 산술 연산자

- <b>2개</b>의 피연산자를 산술 연산하여 숫자 값을 만듦.

- 종류 : `+`(덧셈), `-`(뺄셈), `*`(곱셈), `/`(나눗셈), `%`(나머지)

- 이항 산술 연산자는 부수 효과가 없음.

### 단항(unary) 산술 연산자

- <b>1개</b>의 피연산자를 산술 연산하여 숫자 값을 만듦.

- 종류 : `++`(피연산자 1 증가), `--`(피연산자 1 감소), `+`(아무 효과도 없음. 숫자로 명시적 타입 변환할 때 주로 사용), `-`(양수는 음수로, 음수는 양수로 반전한 값을 반환)

- 이 중 `++`, `--`는 부수 효과가 있음. → <b>암묵적 할당</b>

- `++`, `--`는 위치에 의미가 있음.

### 문자열 연결 연산자

- `+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하며, 그 외의 경우에는 산술 연산자로서 동작한다.

___
## 할당 연산자(assignment operator)

- 할당 연산자는 우항에 있는 피연산자의 <b>평가 결과</b>를 좌항에 있는 변수에 <b>할당</b>함.

- 값을 <b>할당</b>하므로, 좌항에 있는 변수의 값이 변하는 <b>부수 효과가 있음</b>.

- 종류 : `=`, `+=`, `-=`, `*=`, `/=`, `%=`

- <b>할당문</b>은 값으로 평가될 수 있는 문이므로 <b>표현식</b>임. 따라서 할당문을 다른 변수에 할당할 수도 있음.

- 연쇄 할당은 오른쪽에서 왼쪽으로 진행됨.

___
## 비교 연산자(comparison operator)

- 비교 연산자는 좌항과 우항의 피연산자를 비교한 다음, 그 결과를 <b>불리언 값</b>으로 반환함.

- 비교 연산자는 &lt;if문&gt;이나 &lt;for문&gt;과 같은 제어문의 <b>조건식</b>에서 주로 사용함.

### 동등 비교 연산자 vs 일치 비교 연산자

- 동등 비교 연산자(loose equality)는 느슨한 비교를 하고, 일치 비교 연산자(strict equality)는 엄격한 비교를 함.

- 동등/부동등 비교 연산자 (`==`, `!=`)

  - 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교함.

  - 결과를 예측하기 어려우므로 사용 비추

- 일치/불일치 비교 연산자 (`===`, `!==`)

  - 암묵적 타입 변환 없이 값을 비교함.

  - 특이 case : `NaN` → 자기자신과 일치하지 않는 유일한 값

    ```js
    console.log(NaN === NaN); // false
    ```

    - 따라서 어떤 숫자가 `NaN`인지 조사하려는 경우, 빌트인 함수인 `isNaN()`을 사용할 것

    - `isNaN()` 함수는 지정한 값이 `NaN`인지 확인하고, 그에 대한 결과를 불리언 값으로 반환함.

      ```js
      console.log(isNaN(NaN)); // true
      console.log(isNaN(1 + undefined)); // true
      console.log(isNaN(undefined)); // true
      console.log(isNaN(true)); // false(암묵적 타입 변환 주의)
      ```

    - 또는 `Object.is(인자1, 인자2)` 메서드를 사용해서도 `NaN` 값인지 아닌지를 조사할 수 있음.

    - `Object.is(인자1, 인자2)` 메서드는 ES6에서 도입된 메서드로, 인수로 전달된 두 값이 같은 값인지를 판단함.

      ```js
      console.log(NaN === NaN); // false
      console.log(Object.is(NaN, NaN)); // true
      ```

### 대소 관계 비교 연산자

- 대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환함.

- 종류 : `>`, `<`, `>=`, `<=`

___
## 삼항 조건 연산자(ternary operator)

- 'ternary'는 3이라는 의미를 지님.

- 삼항 조건 연산자는 조건식의 평가 결과게 따라 반환할 값을 결정함.

- 변수를 선언하면서 동시에 할당하는 것 가능

- 삼항 조건 연산자는 결국 표현식임.

- 삼항 조건 연산자는 &lt;if...else문&gt;으로도 나타낼 수 있음.

  - 삼항 조건 연산자는 표현식이므로 값처럼 사용할 수 있는 반면, &lt;if...else문&gt;는 표현식이 아니므로 값처럼 사용할 수 없음.

  - 조건에 따라 수행해야 할 문이 하나가 아니라 여러 개라면, 가독성 측면에서 &lt;if...else문&gt;을 사용하는 편이 더 나음.

- 사용 방법

  ```js
  조건식 ? 조건식이 true로 평가될 때 반환할 값 : 조건식이 false로 평가될 때 반환할 값
  ```

  - 만약 조건식의 평가 결과가 불리언 값이 아니면, 불리언 값으로 암묵적 타입 변환됨.

- 예제

  ```js
  const today = new Date();
  const month = today.getMonth() + 1;
  const season = month <= 6 ? 'the first half year' : 'the second half year';

  console.log(`month: ${month}, season: ${season}`);
  // month: 1, season: the first half year
  ```

___
## 논리 연산자(logical operator)

- 피연산자를 논리 연산함.

- 종류 : `||`(논리합(OR)), `&&`(논리곱(AND)), `!`(부정(NOT))

  - `||`(논리합(OR))

    - 좌항 피연산자와 우항 피연산자 중 하나만 참이어도 `true` 값 반환

    - 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨.

    - 평가 결과가 불리언 값이 아닐 수도 있음.

  - `&&`(논리곱(AND))

    - 좌항 피연산자와 우항 피연산자 모두 참이어야 `true` 값 반환

    - 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨.

    - 평가 결과가 불리언 값이 아닐 수도 있음.

  - `!`(부정(NOT))

    - 불리언 값 반전하여 반환

    - 피연산자가 반드시 불리언 값일 필요는 없으며, 이 경우 불리언 타입으로 암묵적 타입 변환됨.

    - 평가 결과가 언제나 불리언 값임.

- 논리 연산자를 사용할 때는 가장 헤비한 피연산자를 제일 뒤에 배치하여, 마지막에 평가되도록 하는 것이 성능상 좋음.

- 드모르간의 법칙

  ```js
  !(a || b) === (!a && !b);
  !(a && b) === (!a || !b);
  ```

  - 이외에도 코드의 가독성을 위해 활용할 수 있는 논리 연산의 여러가지 법칙들이 있음. [(링크)](https://helloworldjavascript.net/pages/150-boolean.html)

___
## 그룹 연산자

- 그룹 연산자 : `()`(소괄호)로 피연산자를 감싸는 것

- 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있음.

- 연산자 우선순위는 그룹 연산자가 가장 높으므로, 그룹 연산자로 감싼 피연산자(표현식)가 가장 먼저 평가됨.

___
## `typeof` 연산자

___
## 지수 연산자

___
## 연산자의 부수 효과

___
## 연산자 우선순위

___
## 연산자 결합 순서

